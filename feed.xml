<?xml version="1.0" encoding="utf-8"?><?xml-stylesheet type="text/xml" href="https://junwin.github.io//feed.xslt.xml"?><feed xmlns="http://www.w3.org/2005/Atom"><generator uri="http://jekyllrb.com" version="3.3.1">Jekyll</generator><link href="https://junwin.github.io//feed.xml" rel="self" type="application/atom+xml" /><link href="https://junwin.github.io//" rel="alternate" type="text/html" /><updated>2017-01-25T08:14:32-06:00</updated><id>https://junwin.github.io///</id><title type="html">John Unwin’s ramblings</title><subtitle>Some ramblings about different topics
</subtitle><entry><title type="html">testing notes</title><link href="https://junwin.github.io//jekyll/update/2017/01/25/testing.html" rel="alternate" type="text/html" title="testing notes" /><published>2017-01-25T08:05:18-06:00</published><updated>2017-01-25T08:05:18-06:00</updated><id>https://junwin.github.io//jekyll/update/2017/01/25/testing</id><content type="html" xml:base="https://junwin.github.io//jekyll/update/2017/01/25/testing.html">&lt;p&gt;In his book Succeeding with Agile Mike Cohn outlines the Test Pyramid&lt;/p&gt;

&lt;p&gt;Unit tests
Service tests
End-to-end tests&lt;/p&gt;

&lt;p&gt;Beware of snow cones, Cohn’s pyramid inverted where there are more End-to-end and Service tests than unit tests - characterized as by very slow test runs and slow feedback.&lt;/p&gt;

&lt;p&gt;End-to-end testing can be tricky e.g. What versions of the different combined  services do we want to use (current prod or new release candidates), also duplication of tests that each individual service would run.
Could have all the individual services “fan in” to a general end-to-end testing, downsides can be flaky and brittle tests, these can fail for a variety of resons that are not related to the services, and can precipitate “normalization of deviance” - Diane Vaughan. Need to remove or fix flaky tests!&lt;/p&gt;

&lt;p&gt;Version Numbers - avoid inadvertently having a single version number for N services “Now you have 2.1.0 problems” Brandon Bryars - this results in loosing a key advantage of being able to deploy single services&lt;/p&gt;

&lt;p&gt;Consumer Driven Tests - these can help reduce the issues in E2E testing by defining consumer driven contracts, these reflect how different consumers of the service use the service, they are at about the same level in the pyramid as service tests.
E2E tests can be like training wheels precursor to better CDTs&lt;/p&gt;

&lt;p&gt;You cant reduce bugs in prod to 0, and there are diminishing returns&lt;/p&gt;

&lt;p&gt;Blue/Green testing - 2 versions deployed to Prod, ability to switch requests to one, but rapid fall back to the other.&lt;/p&gt;

&lt;p&gt;Canary testing -does it work as expected, e.g. Netflicks recommender systems validate the number of sales does not drop. Can either divert real production request to the service or replicate some requests to compare results Vs. current prod.&lt;/p&gt;

&lt;p&gt;Mean time between failures Vs. Mean time to repair&lt;/p&gt;

&lt;p&gt;Cross-functional testing - covers effects/behaviors that cannot be implemented like a normal feature - often affected by cross cutting concerns when developing a service e.g. latency, number of supported users, security, way the UI works&lt;/p&gt;

&lt;p&gt;Performance tests&lt;/p&gt;</content><summary type="html">In his book Succeeding with Agile Mike Cohn outlines the Test Pyramid</summary></entry><entry><title type="html">design decisions</title><link href="https://junwin.github.io//jekyll/update/2017/01/25/designDecisions.html" rel="alternate" type="text/html" title="design decisions" /><published>2017-01-25T08:05:18-06:00</published><updated>2017-01-25T08:05:18-06:00</updated><id>https://junwin.github.io//jekyll/update/2017/01/25/designDecisions</id><content type="html" xml:base="https://junwin.github.io//jekyll/update/2017/01/25/designDecisions.html">&lt;p&gt;1)  SOA Vs ESB Vs Staged Events
In the context of trade flow I do not think this is appropriate because of the point to point nature of SOA, which introduces unnecessary coupling.&lt;/p&gt;

&lt;p&gt;Enterprise Service Bus bases architecture (ESB)
An ESB typically provides features to assist developers in translating and converting the format of the requests and responses that concern them as well as filtering and content-based routing capabilities. These welcome benefits need to offset against the fact that the underlying architecture is generally still point to point SOA with the coupling issues.&lt;/p&gt;

&lt;p&gt;An event driven architecture (EDA) can will deliver the same filtering, transforming and routing capabilities as an ESB, but with a less “point to point” design that emphasizes decentralization and decoupling of systems. Essentially this model consists of a messaging fabric that connects a set of applications (Producers and Consumers) where all participants can potentially see all events. It hinges around using a canonical data model(e.g. trades and allocations rendered a FIX 5.0) for all of the content to significantly reduce coupling.&lt;/p&gt;

&lt;p&gt;A staged event driven architecture (SEDA) is an extension of an EDA except the use of a pipeline of applications is made explicit.
dsff&lt;/p&gt;</content><summary type="html">1)  SOA Vs ESB Vs Staged Events
In the context of trade flow I do not think this is appropriate because of the point to point nature of SOA, which introduces unnecessary coupling.</summary></entry><entry><title type="html">Welcome to Jekyll!</title><link href="https://junwin.github.io//jekyll/update/2017/01/24/welcome-to-jekyll.html" rel="alternate" type="text/html" title="Welcome to Jekyll!" /><published>2017-01-24T15:45:18-06:00</published><updated>2017-01-24T15:45:18-06:00</updated><id>https://junwin.github.io//jekyll/update/2017/01/24/welcome-to-jekyll</id><content type="html" xml:base="https://junwin.github.io//jekyll/update/2017/01/24/welcome-to-jekyll.html">&lt;p&gt;You’ll find this post in your &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run &lt;code class=&quot;highlighter-rouge&quot;&gt;jekyll serve&lt;/code&gt;, which launches a web server and auto-regenerates your site when a file is updated.&lt;/p&gt;

&lt;p&gt;To add new posts, simply add a file in the &lt;code class=&quot;highlighter-rouge&quot;&gt;_posts&lt;/code&gt; directory that follows the convention &lt;code class=&quot;highlighter-rouge&quot;&gt;YYYY-MM-DD-name-of-post.ext&lt;/code&gt; and includes the necessary front matter. Take a look at the source for this post to get an idea about how it works.&lt;/p&gt;

&lt;p&gt;Jekyll also offers powerful support for code snippets:&lt;/p&gt;

&lt;figure class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-ruby&quot; data-lang=&quot;ruby&quot;&gt;&lt;span class=&quot;k&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
  &lt;span class=&quot;nb&quot;&gt;puts&lt;/span&gt; &lt;span class=&quot;s2&quot;&gt;&quot;Hi, &lt;/span&gt;&lt;span class=&quot;si&quot;&gt;#{&lt;/span&gt;&lt;span class=&quot;nb&quot;&gt;name&lt;/span&gt;&lt;span class=&quot;si&quot;&gt;}&lt;/span&gt;&lt;span class=&quot;s2&quot;&gt;&quot;&lt;/span&gt;
&lt;span class=&quot;k&quot;&gt;end&lt;/span&gt;
&lt;span class=&quot;n&quot;&gt;print_hi&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s1&quot;&gt;'Tom'&lt;/span&gt;&lt;span class=&quot;p&quot;&gt;)&lt;/span&gt;
&lt;span class=&quot;c1&quot;&gt;#=&amp;gt; prints 'Hi, Tom' to STDOUT.&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/figure&gt;

&lt;p&gt;Check out the &lt;a href=&quot;http://jekyllrb.com/docs/home&quot;&gt;Jekyll docs&lt;/a&gt; for more info on how to get the most out of Jekyll. File all bugs/feature requests at &lt;a href=&quot;https://github.com/jekyll/jekyll&quot;&gt;Jekyll’s GitHub repo&lt;/a&gt;. If you have questions, you can ask them on &lt;a href=&quot;https://talk.jekyllrb.com/&quot;&gt;Jekyll Talk&lt;/a&gt;.&lt;/p&gt;</content><summary type="html">You’ll find this post in your _posts directory. Go ahead and edit it and re-build the site to see your changes. You can rebuild the site in many different ways, but the most common way is to run jekyll serve, which launches a web server and auto-regenerates your site when a file is updated.</summary></entry><entry><title type="html">Continous Delivery</title><link href="https://junwin.github.io//jekyll/update/2017/01/24/continuous-delivery.html" rel="alternate" type="text/html" title="Continous Delivery" /><published>2017-01-24T15:45:18-06:00</published><updated>2017-01-24T15:45:18-06:00</updated><id>https://junwin.github.io//jekyll/update/2017/01/24/continuous-delivery</id><content type="html" xml:base="https://junwin.github.io//jekyll/update/2017/01/24/continuous-delivery.html">&lt;p&gt;Continuous Integration
Continuous Delivery&lt;/p&gt;

&lt;p&gt;Continuous Integration(CI)
Enable you to make changes quickly and easily
Auto Detect code committed
Build
Run Unit Tests
Deploy Service
Run Service tests&lt;/p&gt;

&lt;p&gt;Jez Humble - 3 questions
Do you check into the mainline each day?
This includes integrating short lived branches to the main.&lt;/p&gt;

&lt;p&gt;Do you have a suite of tests to validate your changes?&lt;/p&gt;

&lt;p&gt;When the build is broken is it the #1 team priority to fix it?&lt;/p&gt;

&lt;p&gt;Options&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Global Build for all services (clumsy when there are numerous service, plus how do you know what to deploy)&lt;/li&gt;
  &lt;li&gt;Single Source tree N builds (at a folder level) - can encourage coupling by checking in changes for N services once&lt;/li&gt;
  &lt;li&gt;Single CI Process per Service - each service has its own repo(code and tests) and build process - implies a repo per service and a build for each service&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Principle&lt;/p&gt;
&lt;ul&gt;
  &lt;li&gt;Avoid lock-step releases&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Exceptions
At the start may well be better to go for option 1 while the service boundaries are in some flux, then move them to 3 as API’s stabilize&lt;/p&gt;

&lt;p&gt;Continuous Delivery
Build Pipelines and continuous delivery(compile and unit tests, Slow Tests, deploy UAT, performance tests, deploy to prod)
Model the standard release process
Aim is to get quick feedback on the production readiness of each and every check-in
One pipeline per service&lt;/p&gt;

&lt;p&gt;Artifacts
jars, wars or rpm, NuGet, chocolaty
What about multiple OS’s
Custom VM images
Netflicks bake their services as AWS images (AMI’s Amazon machine images)&lt;/p&gt;

&lt;p&gt;Immutable Server
To avoid configuration drift, you need the pipeline to build an entire machine.&lt;/p&gt;

&lt;p&gt;Service Configuration
Avoid building and artifact per environment (how can you really validate, plus need to store secure ids etc.), use settings file or configuration system.&lt;/p&gt;

&lt;p&gt;Mapping Services to machines(Hosts)
Think of hosts as an OS where a service can be deployed - physical hardware can support 1..N hosts&lt;/p&gt;

&lt;p&gt;N Services per host is simple but has issues (performance of one affects others, different dependencies, risk, ripple affect, may results in centralized team to manage host, limits deployment options)&lt;/p&gt;

&lt;p&gt;Application Containers (IIS, Tomcat) Provides clustering, monitoring and more efficient use of resources, but you need to buy into the technology stack, the features offered may constrain and not scale, lifecycle management is more complex, monitoring and analysis is harder if N services share some container&lt;/p&gt;

&lt;p&gt;Single Service per host - can reduce single points of failure, simplify monitoring and remediation, an outage only affects a single host, can scale service independently of each other, can use services deployed as images and the immutable server pattern.
Note that single service per host can be quite expensive an extreme would be where a host is a physical machine, hence VMs and containers like Docker&lt;/p&gt;

&lt;p&gt;Platform as a Service PaaS - takes an artifact like a war file or gem and provisions and runs them.&lt;/p&gt;

&lt;p&gt;Automation
A must if you go down a Service per Host route&lt;/p&gt;

&lt;p&gt;Appendix - Artifacts
You add web components to a J2EE application in a package called a web application archive (WAR), which is a JAR similar to the package used for Java class libraries. A WAR usually contains other resources besides web components, including:&lt;/p&gt;

&lt;p&gt;Server-side utility classes (database beans, shopping carts, and so on).
Static web resources (HTML, image, and sound files, and so on)
Client-side classes (applets and utility classes)
A WAR has a specific hierarchical directory structure. The top-level directory of a WAR is the document root of the application. The document root is where JSP pages, client-side classes and archives, and static web resources are stored.&lt;/p&gt;

&lt;p&gt;So a .war is a .jar, but it contains web application components and is laid out according to a specific structure. A .war is designed to be deployed to a web application server such as Tomcat or Jetty or a Java EE server such as JBoss or Glassfish.&lt;/p&gt;</content><summary type="html">Continuous Integration
Continuous Delivery</summary></entry></feed>
